# 前端代码具体问题清单

本文档列出了代码中具体的问题位置和改进建议，便于开发者逐个修复。

---

## 1. utils/request.js 问题

### 问题 1.1：错误处理不完善
**位置：** `utils/request.js:47-87`

**问题：**
```javascript
if (res.statusCode >= 200 && res.statusCode < 300) {
    if (res.data.success !== false && res.data.code !== -1) {
        resolve(res.data);
    }
}
```
- 业务成功判定逻辑不清晰，`success !== false` 意味着 undefined 也算成功
- 错误码判定不统一

**建议：**
```javascript
// 明确定义成功和失败的标准
if (res.statusCode >= 200 && res.statusCode < 300) {
    // 统一约定：code === 0 表示成功
    if (res.data && res.data.code === 0) {
        resolve(res.data);
    } else {
        const error = {
            code: res.data?.code || -1,
            message: res.data?.message || '请求失败'
        };
        if (showError) {
            wx.showToast({ title: error.message, icon: 'none' });
        }
        reject(error);
    }
}
```

### 问题 1.2：401 处理逻辑有隐患
**位置：** `utils/request.js:66-77`

**问题：**
```javascript
else if (res.statusCode === 401) {
    wx.removeStorageSync('token');
    wx.removeStorageSync('openid');
    wx.removeStorageSync('userInfo');
    wx.showToast({ title: '登录已过期，请重新进入', icon: 'none' });
    const appInstance = getApp();
    if (appInstance && appInstance.wxLogin) {
        appInstance.wxLogin().catch(() => {});
    }
}
```
- 自动重新登录可能导致死循环（如果登录接口也返回 401）
- 没有防止并发的多次登录尝试
- 用户体验差，应该给用户选择是否重新登录

**建议：**
```javascript
// 添加登录锁
let isRefreshingToken = false;
let refreshSubscribers = [];

function onTokenRefreshed(token) {
    refreshSubscribers.forEach(callback => callback(token));
    refreshSubscribers = [];
}

function addRefreshSubscriber(callback) {
    refreshSubscribers.push(callback);
}

// 在 401 处理中
if (res.statusCode === 401) {
    if (!isRefreshingToken) {
        isRefreshingToken = true;

        wx.removeStorageSync('token');
        wx.removeStorageSync('openid');
        wx.removeStorageSync('userInfo');

        wx.showModal({
            title: '登录已过期',
            content: '请重新登录',
            showCancel: false,
            success: () => {
                const appInstance = getApp();
                if (appInstance && appInstance.wxLogin) {
                    appInstance.wxLogin()
                        .then(result => {
                            isRefreshingToken = false;
                            onTokenRefreshed(result.token);
                        })
                        .catch(() => {
                            isRefreshingToken = false;
                        });
                }
            }
        });
    }

    return new Promise((resolve) => {
        addRefreshSubscriber((token) => {
            // 重试原请求
            request({ ...options, token }).then(resolve);
        });
    });
}
```

---

## 2. app.js 问题

### 问题 2.1：重复的配置
**位置：** `app.js:5-10` 和 `utils/request.js:9-13`

**问题：**
```javascript
// app.js
globalData: {
    baseUrl: 'https://api.jxalk.cn/api'
}

// utils/request.js
const config = {
    baseUrl: 'https://api.jxalk.cn/api',
    timeout: 15000
};
```
- 同一配置在两个地方定义
- 容易导致不一致

**建议：**
```javascript
// config/index.js
export const APP_CONFIG = {
    baseUrl: 'https://api.jxalk.cn/api',
    timeout: 15000,
    version: '1.0.0'
};

// app.js 和 utils/request.js 都引用这个配置
import { APP_CONFIG } from './config';
```

### 问题 2.2：自动登录逻辑不合理
**位置：** `app.js:36-56`

**问题：**
```javascript
async autoLogin() {
    // 检查本地是否有登录信息
    const userInfo = wx.getStorageSync('userInfo');
    const openid = wx.getStorageSync('openid');
    const token = wx.getStorageSync('token');

    if (userInfo && openid && token) {
        this.globalData.userInfo = userInfo;
        this.globalData.openid = openid;
        this.globalData.token = token;
        this.globalData.isLoggedIn = true;
        console.log('从缓存恢复登录状态');
        return;
    }

    // 没有缓存，执行微信登录
    await this.wxLogin();
}
```
- 没有验证 token 是否有效，可能使用过期 token
- 应该验证 token 后再标记为已登录

**建议：**
```javascript
async autoLogin() {
    const token = wx.getStorageSync('token');

    if (token) {
        // 验证 token 是否有效
        try {
            const res = await require('./utils/request').get('/user/profile');
            if (res.code === 0) {
                // token 有效，恢复登录状态
                this.globalData.userInfo = res.data;
                this.globalData.token = token;
                this.globalData.isLoggedIn = true;
                console.log('登录状态恢复成功');
                return;
            }
        } catch (err) {
            console.log('token 已失效，清除本地数据');
            wx.removeStorageSync('token');
            wx.removeStorageSync('userInfo');
        }
    }

    // Token 无效或不存在，静默登录
    try {
        await this.wxLogin();
    } catch (err) {
        console.log('自动登录失败，等待用户手动登录');
    }
}
```

---

## 3. pages/index/index.js 问题

### 问题 3.1：数据加载错误处理不足
**位置：** `pages/index/index.js:67-145`

**问题：**
```javascript
try {
    const results = await Promise.all([
        get('/content/banners', { position: 'home' }).catch(() => ({ data: [] })),
        get('/products', { limit: 10 }).catch(() => ({ data: { list: [] } })),
        get('/categories').catch(() => ({ data: [] }))
    ]);
    // ...
} catch (err) {
    console.error('加载失败:', err);
    this.setData({ loading: false });
}
```
- 使用 `.catch(() => ({ data: [] }))` 会隐藏真实错误
- 用户不知道发生了什么
- 应该区分部分失败和完全失败

**建议：**
```javascript
async loadData() {
    this.setData({ loading: true });

    try {
        const results = await Promise.allSettled([
            get('/content/banners', { position: 'home' }),
            get('/products', { limit: 10 }),
            get('/categories')
        ]);

        const [bannersRes, productsRes, categoriesRes] = results;

        // 检查是否所有请求都失败
        const allFailed = results.every(r => r.status === 'rejected');
        if (allFailed) {
            wx.showToast({ title: '加载失败，请下拉刷新', icon: 'none' });
            this.setData({ loading: false, hasError: true });
            return;
        }

        // 处理成功的数据
        const banners = bannersRes.status === 'fulfilled' ? (bannersRes.value.data || []) : [];
        const products = productsRes.status === 'fulfilled' ? (productsRes.value.data?.list || []) : [];
        const categories = categoriesRes.status === 'fulfilled' ? (categoriesRes.value.data || []) : [];

        // 如果部分失败，给予提示
        const failedCount = results.filter(r => r.status === 'rejected').length;
        if (failedCount > 0) {
            wx.showToast({
                title: `部分数据加载失败(${failedCount}/${results.length})`,
                icon: 'none'
            });
        }

        // 设置数据
        this.setData({
            banners,
            products: this.processProducts(products),
            categories,
            topCategories: this.buildTopCategories(categories),
            loading: false,
            hasError: false
        });
    } catch (err) {
        console.error('加载失败:', err);
        wx.showToast({ title: '加载失败，请稍后重试', icon: 'none' });
        this.setData({ loading: false, hasError: true });
    }
}
```

### 问题 3.2：图片解析逻辑重复
**位置：** `pages/index/index.js:99-120` 和 `pages/index/index.js:203-222`

**问题：**
同样的图片解析逻辑出现两次，代码重复。

**建议：**
提取为工具函数（见前面的建议）

---

## 4. pages/product/detail.js 问题

### 问题 4.1：价格计算逻辑硬编码
**位置：** `pages/product/detail.js:68-79`

**问题：**
```javascript
const roleLevel = user.role_level || 0;

let displayPrice = product.retail_price;
if (roleLevel === 1) {
    displayPrice = product.price_member || product.retail_price;
} else if (roleLevel === 2) {
    displayPrice = product.price_leader || product.price_member || product.retail_price;
} else if (roleLevel === 3) {
    displayPrice = product.price_agent || product.price_leader || product.price_member || product.retail_price;
}
```
- 魔法数字 1、2、3
- 逻辑重复出现在多个文件
- 难以维护和修改

**建议：**
使用前面提到的工具函数

### 问题 4.2：SKU 选择逻辑不完整
**位置：** `pages/product/detail.js:159-171`

**问题：**
```javascript
onSpecSelect(e) {
    const { key, val } = e.currentTarget.dataset;
    const selectedSpecs = this.data.selectedSpecs || {};
    selectedSpecs[key] = val;
    this.setData({ selectedSpecs });
    // ... (Logic skipped for brevity, assuming backend returns SKUs)
}
```
- 注释表明逻辑不完整
- 没有根据选择的规格找到对应的 SKU
- 可能导致用户选择无效组合

**建议：**
```javascript
onSpecSelect(e) {
    const { key, value } = e.currentTarget.dataset;
    const selectedSpecs = { ...this.data.selectedSpecs, [key]: value };

    // 查找匹配的 SKU
    const matchedSku = this.findMatchingSku(selectedSpecs);

    // 更新可选规格（禁用不可选的规格组合）
    const availableSpecs = this.getAvailableSpecs(selectedSpecs);

    this.setData({
        selectedSpecs,
        selectedSku: matchedSku,
        availableSpecs
    });
}

findMatchingSku(selectedSpecs) {
    return this.data.skus.find(sku => {
        // 根据规格匹配 SKU
        return Object.entries(selectedSpecs).every(([key, value]) => {
            return sku.specs && sku.specs[key] === value;
        });
    });
}

getAvailableSpecs(selectedSpecs) {
    // 计算当前选择下，哪些规格值是可用的
    // 防止用户选择无库存的组合
}
```

---

## 5. pages/cart/cart.js 问题

### 问题 5.1：选中状态只在前端维护
**位置：** `pages/cart/cart.js:95-116`

**问题：**
```javascript
onToggleSelect(e) {
    const index = e.currentTarget.dataset.index;
    const key = `cartItems[${index}].selected`;

    this.setData({
        [key]: !this.data.cartItems[index].selected
    });

    this.calculateTotal();
}
```
- 选中状态只在前端维护，不同步到后端
- 用户在不同设备上看到的选中状态不一致
- 如果刷新页面，选中状态会丢失

**建议：**
```javascript
async onToggleSelect(e) {
    const index = e.currentTarget.dataset.index;
    const item = this.data.cartItems[index];
    const newSelected = !item.selected;

    try {
        // 同步到后端
        await put(`/cart/${item.id}`, { selected: newSelected });

        // 更新前端状态
        const key = `cartItems[${index}].selected`;
        this.setData({ [key]: newSelected });
        this.calculateTotal();
    } catch (err) {
        wx.showToast({ title: '操作失败', icon: 'none' });
        console.error('更新选中状态失败:', err);
    }
}
```

### 问题 5.2：价格计算使用的字段不一致
**位置：** `pages/cart/cart.js:48` 和 `pages/order/confirm.js`

**问题：**
```javascript
// pages/cart/cart.js
price: parseFloat(item.sku?.retail_price || item.product?.retail_price || 0)

// pages/order/confirm.js - 使用的是 effective_price
price: parseFloat(item.effective_price || item.price || 0)
```
- 购物车页面和订单确认页面使用的价格字段不一致
- 可能导致价格显示不一致

**建议：**
统一价格字段的使用，明确定义各个场景应该使用哪个价格字段。

---

## 6. pages/user/user.js 问题

### 问题 6.1：并行请求没有错误隔离
**位置：** `pages/user/user.js:56-59`

**问题：**
```javascript
// 并行加载所有数据
this.loadOrderCounts();
this.loadDistributionInfo();
this.loadNotificationsCount();
```
- 如果某一个请求失败，不影响其他数据展示，但代码中每个函数都是独立的 try-catch
- 没有统一的错误处理
- 用户不知道哪些数据加载失败了

**建议：**
```javascript
async loadUserInfo() {
    // ...主逻辑

    // 并行加载，使用 Promise.allSettled 避免单个失败影响其他
    const results = await Promise.allSettled([
        this.loadOrderCounts(),
        this.loadDistributionInfo(),
        this.loadNotificationsCount()
    ]);

    // 检查是否有失败的请求
    const failed = results.filter(r => r.status === 'rejected');
    if (failed.length > 0) {
        console.warn('部分数据加载失败:', failed);
        // 可以在页面上显示一个提示
        this.setData({ partialError: true });
    }
}
```

### 问题 6.2：修改昵称缺少防抖
**位置：** `pages/user/user.js:151-169`

**问题：**
用户可能连续点击确认按钮，导致多次提交。

**建议：**
```javascript
async onConfirmNickname() {
    // 防止重复提交
    if (this.submitting) return;

    const nickname = this.data.newNickname.trim();
    if (!nickname) {
        wx.showToast({ title: '昵称不能为空', icon: 'none' });
        return;
    }

    this.submitting = true;

    try {
        const res = await put('/user/profile', { nickname });
        if (res.code === 0) {
            wx.showToast({ title: '修改成功', icon: 'success' });
            this.setData({ showNicknameModal: false });
            this.loadUserInfo();
        } else {
            wx.showToast({ title: res.message || '修改失败', icon: 'none' });
        }
    } catch (err) {
        wx.showToast({ title: '修改失败', icon: 'none' });
    } finally {
        this.submitting = false;
    }
}
```

---

## 7. 组件问题

### 问题 7.1：product-card 组件功能过于简单
**位置：** `components/product-card/product-card.js`

**问题：**
```javascript
Component({
  properties: {
    product: { type: Object, value: {} }
  },
  methods: {
    onTap() {
      this.triggerEvent('click', { product: this.data.product });
    }
  }
});
```
- 组件功能单一，几乎没有封装任何逻辑
- 缺少属性验证
- 缺少默认插槽支持

**建议：**
```javascript
Component({
    options: {
        styleIsolation: 'shared',
        multipleSlots: true
    },

    properties: {
        product: {
            type: Object,
            value: {},
            observer(newVal) {
                // 处理商品数据
                this.processProduct(newVal);
            }
        },
        showAddCart: {
            type: Boolean,
            value: true
        },
        layout: {
            type: String,
            value: 'vertical' // vertical | horizontal
        }
    },

    data: {
        displayPrice: '0.00',
        firstImage: ''
    },

    methods: {
        processProduct(product) {
            // 处理图片
            const images = parseImages(product.images);
            // 计算价格
            const userInfo = wx.getStorageSync('userInfo') || {};
            const displayPrice = calculatePrice(product, userInfo.role_level);

            this.setData({
                firstImage: images[0] || '/assets/images/placeholder.svg',
                displayPrice
            });
        },

        onTap() {
            this.triggerEvent('tap', { product: this.data.product });
        },

        onAddCart(e) {
            e.stopPropagation();
            this.triggerEvent('addcart', { product: this.data.product });
        }
    }
});
```

---

## 8. 通用建议

### 8.1 创建工具函数库

创建 `utils/helpers.js`：

```javascript
/**
 * 防抖函数
 */
export function debounce(fn, delay = 300) {
    let timer = null;
    return function(...args) {
        if (timer) clearTimeout(timer);
        timer = setTimeout(() => {
            fn.apply(this, args);
        }, delay);
    };
}

/**
 * 节流函数
 */
export function throttle(fn, delay = 300) {
    let lastTime = 0;
    return function(...args) {
        const now = Date.now();
        if (now - lastTime > delay) {
            lastTime = now;
            fn.apply(this, args);
        }
    };
}

/**
 * 深拷贝
 */
export function deepClone(obj) {
    if (obj === null || typeof obj !== 'object') return obj;
    if (obj instanceof Date) return new Date(obj);
    if (obj instanceof Array) return obj.map(item => deepClone(item));

    const cloned = {};
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            cloned[key] = deepClone(obj[key]);
        }
    }
    return cloned;
}

/**
 * 格式化时间
 */
export function formatTime(timestamp, format = 'YYYY-MM-DD HH:mm:ss') {
    const date = new Date(timestamp);
    const map = {
        'YYYY': date.getFullYear(),
        'MM': String(date.getMonth() + 1).padStart(2, '0'),
        'DD': String(date.getDate()).padStart(2, '0'),
        'HH': String(date.getHours()).padStart(2, '0'),
        'mm': String(date.getMinutes()).padStart(2, '0'),
        'ss': String(date.getSeconds()).padStart(2, '0')
    };

    return format.replace(/YYYY|MM|DD|HH|mm|ss/g, matched => map[matched]);
}

/**
 * 格式化金额
 */
export function formatMoney(amount, decimals = 2) {
    if (isNaN(amount)) return '0.00';
    return Number(amount).toFixed(decimals);
}

/**
 * 格式化数字（千分位）
 */
export function formatNumber(num) {
    return String(num).replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}
```

### 8.2 创建常量配置文件

创建 `config/constants.js`（前面已提供示例）

### 8.3 创建数据格式化工具

创建 `utils/dataFormatter.js`（前面已提供示例）

---

## 总结

以上列出了代码中最关键的问题和改进建议。建议按照以下顺序修复：

1. **立即修复**（影响功能和用户体验）：
   - 错误处理机制
   - 401 登录循环问题
   - 价格字段不一致问题

2. **高优先级**（影响代码质量）：
   - 提取公共工具函数
   - 移除重复代码
   - 统一配置管理

3. **中优先级**（优化用户体验）：
   - 完善 SKU 选择逻辑
   - 添加防抖节流
   - 优化加载状态

4. **持续优化**（长期改进）：
   - 组件化重构
   - 添加测试
   - 性能优化

每个问题都提供了具体的代码位置和改进方案，可以逐步实施。
